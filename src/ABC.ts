class A {
  // ...
  getB() {
    return new B();
  }
}

class B {
  // ...
  getC() {
    return new C();
  }
}

class C {
  // ...
  doSomething() {
    // Логика
  }
}

// Использование транзитивного обращения
new A().getB().getC().doSomething(); // Всё ОК, разве что объявлять переменную не обязательно

/*
 * 1. Ошибки тут нет
 * 2. Однако, если класс C есть в области видимости и не зависит от контекта вызовов A и B,
 *  то можно напрямую вызвать его:
 *  new C().doSomething();
 * */
